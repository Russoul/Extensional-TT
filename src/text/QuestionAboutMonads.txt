Given:
StateT : Type → Monad → (Type → Type)
StateT s m a = s → m (s, a)

pure : a → StateT s m a
pure x s = pure (s, x)

//Bind via join for arbitrary monad
(>>=) : m a → (a → m b) → m b
(t >>= g) = join (m g t)

join : StateT s m (StateT s m a) → StateT s m a
join F s = do
 (s, G) ← F s
 G s

 F s >>= (s, G) ↦ G s >>= (s, x) ↦ pure (s, x)
 =
 join (m ((s, G) ↦ G s >>= (s, x) ↦ pure (s, x)) (F s))
 =
 join (m ((s, G) ↦ join (m ((s, x) ↦ pure (s, x)) (G s))) (F s))

StateT s m α : StateT s m a → StateT s m b
StateT s m α F x = do
  (s, r) ← F x
  pure (s, α r)

State : Type → (Type → Type)
State s a = s → (s, a)

We want to show:
∀s. ∀a. (State s a ≅ (m : Monad) → StateT s m a)

Category of Monads.
Objects are monads
Arrows are functions f : ∀a. M a → N a
a    M a        N a


b    M b        N b

that make the square commute (natural transformation)

that additionally preserve monad structure:
(x : a) ⊦ f (pure x) = pure x : N a
(t : M² a) ⊦ f (join t) = join (f (m f t) : N² a) : M² a → N² a
(α : a → b) (t : M a) ⊦ f (M α t) = N α (f t) : N b

////////
M (f @ a) : M² a → M (N a)

f @ N a : M (N a) → N² a

M (f @ a) ; f @ N a : M² a → N² a
///////

Checking the identity law:
Given a monad M, we need to provide an arrow:
f : ∀a. M a → M a
such that
f (pure x) = pure x
f (join t) = join ((f @ N a) (m (f @ a) t))
f (M α t) = M α (f t)

take f ≔ id
then:
id (pure x) = pure x ✔
id (join t) = join t ✔
id (M α t) = M α (id t) = M α t ✔

Checking composition law:
Given monads M N O, and arrows
f : ∀a. M a → N a
g : ∀a. N a → O a
we have to provide a composite arrow, that is a function:
h : ∀a. M a → O a
such that
h (pure x) = pure x
h (join t) = join (h (M h t))
h (M α t) = O α (h t)

take h ≔ g ∘ f, hence
we have to show:
*) g (f (pure x)) = pure x
   //f is an arrow hence f (pure x) = pure x
   g (pure x) = pure x
   // g is an arrow hence g (pure x) = pure x
   pure x = pure x ✔
*) g (f (join t)) = join ((g ∘ f) (M (g ∘ f) t))
   //f is an arrow hence f (join t) = join (f (M f t))
   g (join (f (m f t))) = join ((g ∘ f) (M (g ∘ f) t))
   //g is an arrow hence ∀t. g (join t) = join (g (N g t))
   //take t ≔ f (m f t)
   //hence
   //g (join (f (m f t))) = join (g (N g (f (M f t))))
   join (g (N g (f (M f t)))) = join ((g ∘ f) (m (g ∘ f) t))
   //it's enough to show:
   g (N g (f (M f t))) = (g ∘ f) (M (g ∘ f) t)
   //m is a functor hence M (g ∘ f) = M g ∘ M f
   g (N g (f (M f t))) = (g ∘ f) ((M g ∘ M f) t)
   //By definition of function composition:
   g (N g (f (M f t))) = g (f (N g (M f t)))
   //It's enough to show:
   N g (f (M f t)) = f (M g (M f t))
   //
   N g (f (M f t)) = f (M (g ∘ f) t)
   //f preserves map
   N g (f (M f t)) = N (g ∘ f) (f t)
   //f preserves map
   N g (N f (f t)) = N (g ∘ f) (f t)
   //functor composition law
   N (g ∘ f) (f t) = N (g ∘ f) (f t) ✔
*) (g ∘ f) (M α x) = O α ((g ∘ f) x)
   //f preserves map
   g (N α (f x)) = O α ((g ∘ f) x)
   //g preserves map
   O α (g (f x)) = O α ((g ∘ f) x) ✔

Last we need to show that composition is associative:
Given four monads:
M N O P
arrows:
f : M ⇝ N
g : N ⇝ O
h : O ⇝ P
we need to show that:
h ∘ (g ∘ f) = (h ∘ g) ∘ f : M ⇝ P
It's enough to show that
composition of underlying functions is associative:
h ∘ (g ∘ f) = (h ∘ g) ∘ f : M a → P a
But we know that function composition is associative.

(do x <- p; q)
=
p >>= (x ↦ q)
=
join (m (x ↦ q) p)

//Let's see how monad morphism acts on a do-block:
f (m.do x ← p; q)
=
f (join (m (x ↦ q) p))
=
join (f (m f (m (x ↦ q) p)))
=
join (f (m (f ∘ (x ↦ q)) p))
=
join (n (f ∘ (x ↦ q)) (f p))
=
(n.do x ← f p; f q)

We need to show that in the category of monads
StateT s : Monad → Monad
is an endofunctor
We know that action of StateT on monads (by definition)
We need to define its action on monad morphisms:
Given monads M N
and monad morphism  f : M ⇝ N
we need to define:
StateT s f : StateT s M ⇝ StateT s N
that is we need
F : ∀a. StateT s M a → StateT s N a
such that
F (pure x) = pure x
F (join t) = join (F (m F t))
F (StateT s M α x) = StateT s N α (F x)

//In other words we need to provide:
F : ∀a. (s → M (s, a)) → (s → N (s, a))
F γ x = f (γ x)
//now let's see if the equations hold:

*) F (pure x) = pure x : StateT s M a
   //By definition of F
   (s ↦ f (pure x s)) = pure x
   //By definition of pure
   (s ↦ f (pure x s)) = (s ↦ pure (s, x))
   //it's enough to show:
   f (pure x s) = pure (s, x)
   //f preserves pure
   pure x s = pure (s, x)
   //by defition of pure at StateT
   pure (s, x) = pure (s, x) ✔
*) F (join t) = join (F (StateT s M F t))
   //By definition of F
   (x ↦ f (join t x)) = join (x ↦ f (StateT s M F t x))
   //It's enough to show
   f (join t x) = join (x ↦ f (StateT s M F t x)) x
   //By definition of join at StateT:
   f (do (x, G) ← t x; G x) = do (x, G) ← f (StateT s M F t x); G x
   //f preserves do
   do (x, G) ← f (t x); f (G x) = do (x, G) ← f (do (x, r) ← t x; pure (x, F r)); G x
   //f preserves do
   do (x, G) ← f (t x); f (G x) = do (x, G) ← (do (x, r) ← f (t x); f (pure (x, F r))); G x
   //do is associative
   do (x, G) ← f (t x); f (G x) = do (x, r) ← f (t x); (x, G) ← f (pure (x, F r)); G x
   //rename
   do (x, r) ← f (t x); f (r x) = do (x, r) ← f (t x); (x, G) ← f (pure (x, F r)); G x
   //It's enough to show:
   f (r x) = do (x, G) ← f (pure (x, F r)); G x
   //f preserves pure
   f (r x) = do (x, G) ← pure (x, F r); G x
   //do of pure
   f (r x) = F r x
   //By definition of F
   f (r x) = f (r x) ✔
*) F (StateT s M α r) = StateT s N α (F r)
   //it's enough to show
   F (StateT s M α r) x = StateT s N α (F r) x
   //By definition of F
   f (StateT s M α r x) = StateT s N α (F r) x
   // By definition of StateT map
   f (do (x, o) ← r x; pure (x, α o)) = do (x, o) ← F r x; pure (x, α o)
   //By definition of F
   f (do (x, o) ← r x; pure (x, α o)) = do (x, o) ← f (r x); pure (x, α o)
   //f preserves do
   (do (x, o) ← f (r x); f (pure (x, α o))) = do (x, o) ← f (r x); pure (x, α o)
   //f of pure
   (do (x, o) ← f (r x); pure (x, α o)) = do (x, o) ← f (r x); pure (x, α o) ✔

//Hence we've defined the morphism action of the StateT endofunctor.
//We need to show that it preserves functor laws:

//First we need to show that it preserves identity:
Given monad M
F id(M) = id(StateT s M) : ∀a. StateT s M a → StateT s M a
//By definition of F:
(γ x ↦ γ x) = id(StateT s M) : ∀a. StateT s M a → StateT s M a
//We have identity function on the left
id = id(StateT s M) : ∀a. StateT s M a → StateT s M a
//We have identity function on the right by definition of identity morphism
id = id : ∀a. StateT s M a → StateT s M a ✔

//Next we show that it preserves composition:
Given monads M N O
monad morphisms: f : M ⇝ N
                 g : N ⇝ O


F (g ∘ f) = F g ∘ F f : StateT s M a → StateT s O a
//By definition of F
(γ x ↦ (g ∘ f) (γ x)) = (γ x ↦ g (γ x)) ∘ (γ x ↦ f (γ x)) : StateT s M a → StateT s O a
//It's enough to show:
g (f (γ x)) = g (f (γ x)) ✔
//Hence StateT is an endofunctor in the category of monads.

//Our original goal is to show:
∀s. ∀a. (State s a ≅ (m : Monad) → StateT s m a)
//Note that State s a = StateT s id a
//hence
∀s. ∀a. (StateT s id a ≅ (m : Monad) → StateT s m a)

//First let's show that the identity monad is the initial object in the
//category of monads
Id : Type → Type
Id a = a

pure : a → Id a
pure = id

join : Id (Id a) → Id a
join = id

//Hence for arbitrary monad M we need to provide a monad arrow
! : Id ⇝ M
which must be unique

In other words we need to provide:
! : Id a → M a
! = pure

! (pure x) = pure x
! x = pure x
pure x = pure x ✔

! (join x) = join (! (Id ! x))
! x = ! (Id ! x)
! x = ! (! x)
! x = ! (pure x)
pure x = pure x ✔

! (Id f x) = M f (! x)
! (f x) = M f (pure x)
pure (f x) = pure (f x) ✔

//moreover for any arrow
? : ∀a. Id a → M a
//we need to show:
! = ?
//it's enough to show that:
! x = ? x
pure x = ? x //This has to be proven by parametricity somehow.

//We want to apply the Yoneda lemma for StateT endofunctor.
//For that we'll define a set-valued functor:
a ⊦ τ m = StateT s m a

//Yoneda lemma:
a ⊦ τ X ≅ Nat(Hom(X, _), τ)
//take X ≔ Id : Monad
a ⊦ τ Id ≅ Nat(Hom(Id, _), τ)
//Note that for any X: Hom(Id, X) ≅ 𝟙, for Id is the initial object
//Hence Hom(Id, _) = const 𝟙 //Constant functor
                   //Need parametricity here
a ⊦ τ Id ≅ Nat(const 𝟙, τ) ≅ (∀m. τ m)
a ⊦ State s a ≅ Nat(const 𝟙, τ) ≅ (∀m. τ m)
//
a ⊦ State s a ≅ (∀m. StateT s m a)
//
∀a. State s a ≅ (∀m. StateT s m a)

--------------------------------------------------------


//Fix the category of types and functions — Type

//Functor is an endofunctor on Type

//Given a functor F and a type a
//we write
F a : 𝕌
//to represent the functorial action of F on object a.

//Given a functor F and a function f : a → b
//we write
F f : F a → F b
//to represent the functorial action of F on morhism f.

//Notation:
M⁰ a = a
M¹⁺ⁿ a = M (Mⁿ a)

//Monad is a Functor M with additional two functions:
pure : ∀a. a → M a
join : ∀a. M² a → M a
//which satisfy the following laws:
(x : a) ⊦ M f (pure x) = pure (f x)            } naturality laws
(t : M² a) ⊦ M f (join t) = join (M² f t)      }

(t : M a) ⊦ join (pure t) = t                  }
(t : M a) ⊦ join (M pure t) = t                } monoid laws
(t : M³ a) ⊦ join (M join t) = join (join t)   }

//Define a category of Monads:
//Objects are monads
//Arrows are functions f : ∀a. M a → N a
//that additionally have the following properties:
(x : a) ⊦ f (pure x) = pure x : N a
(t : M² a) ⊦ f (join t) = join (f (M f t) : N² a) : N a
(α : a → b) (t : M a) ⊦ f (M α t) = N α (f t) : N b

//Isomorphism between types A and B is a pair of both-way functions between A and B that compose to identity in both ways.

//The goal is to prove:
(∀(M : Monad). ∀a. a → M a) ≅ 𝟙
//In english: the space of functions that for arbitrary monad M, arbitrary type a take an element of a to an element of M a is
//isomorphic to one element space (𝟙).

//PROOF:

//Define a quotient inductive type:
data FreeMonad : 𝕌 → 𝕌 where
  Map : (a → b) → FreeMonad a → FreeMonad b
  Pure : a → FreeMonad a
  Join : FreeMonad² a → FreeMonad a
  //Define Bind
  Bind : FreeMonad a → (a → FreeMonad b) → FreeMonad b
  Bind t f = Join (Map f t)

  //Functor laws
  (t : FreeMonad a) ⊦ Map id t = t : FreeMonad a
  (t : FreeMonad a) ⊦ Map (g ∘ f) t = Map g (Map f t) : FreeMonad a

  //Define
  Map² f = Map (Map f)

  //naturality laws
  Map f (Pure x) = Pure (f x) : FreeMonad a
  (t : FreeMonad² a) ⊦ Map f (Join t) = Join (Map² f t) : FreeMonad a

  //Monoid laws
  (t : FreeMonad a) ⊦ Join (Pure t) = t : FreeMonad a
  (t : FreeMonad a) ⊦ Join (Map Pure t) = t : FreeMonad a
  (t : FreeMonad³ a) ⊦ Join (Map Join t) = Join (Join t) : FreeMonad a


//Let's prove that
(t : FreeMonad a) ⊦ Bind t Pure = t : FreeMonad a
                    Join (Map Pure t) = t ✔

//Let's prove that
(x : a) ⊦ Bind (Pure x) f = f x : FreeMonad b
          Join (Map f (Pure x)) = f x
          Join (Pure (f x)) = f x
          f x = f x ✔

//Let's prove that
(t : FreeMonad a) ⊦ (do y ← (do x ← t; f); g) = (do x ← t; y ← f; g) : FreeMonad a
                    Join (Map (y ↦ g) (do x ← t; f)) = Join (Map (x ↦ do y ← f; g) t)
                    Join (Map (y ↦ g) (Join (Map (x ↦ f) t))) = Join (Map (x ↦ Join (Map (y ↦ g) f)) t)
                    Join (Map (y ↦ g) (Join (Map (x ↦ f) t))) = Join (Map (Join . (x ↦ Map (y ↦ g) f)) t)
                    Join (Map (y ↦ g) (Join (Map (x ↦ f) t))) = Join (Map Join (Map (x ↦ Map (y ↦ g) f) t))
                    Join (Map (y ↦ g) (Join (Map (x ↦ f) t))) = Join (Join (Map (x ↦ Map (y ↦ g) f) t))
                    Join (Join (Map² (y ↦ g) (Map (x ↦ f) t))) = Join (Join (Map (x ↦ Map (y ↦ g) f) t))
                    Map² (y ↦ g) (Map (x ↦ f) t) = Map (Map (y ↦ g) . (x ↦ f)) t
                    Map² (y ↦ g) (Map (x ↦ f) t) = Map (Map (y ↦ g)) (Map (x ↦ f) t)
                    Map² (y ↦ g) (Map (x ↦ f) t) = Map² (y ↦ g) (Map (x ↦ f) t) ✔


//FreeMonad satisfies functor laws and monad laws.

//define
interp : ∀(M : Monad). FreeMonad a → M a
interp M (Pure x) = pure x
interp M (Map f t) = M f (interp M t)
interp M (Join t) = join (M (interp M) (interp M t))

interp M (Map id t) = interp M t
M id (interp M t) = interp M t
interp M t = interp M t ✔

interp M (Map (g ∘ f) t) = interp M (Map g (Map f t))
M (g ∘ f) (interp M t) = interp M (Map g (Map f t))
M (g ∘ f) (interp M t) = M g (interp M (Map f t))
M (g ∘ f) (interp M t) = M g (M f (interp M t))
M g (M f (interp M t)) = M g (M f (interp M t)) ✔

interp M (Map f (Pure x)) = interp M (Pure (f x))
M f (interp M (Pure x)) = pure (f x)
M f (pure x) = pure (f x)
pure (f x) = pure (f x) ✔

interp M (Map f (Join t)) = interp M (Join (Map² f t))
M f (join (M (interp M) (interp M t))) = join (M (interp M) (interp M (Map² f t)))
join (M² f (M (interp M) (interp M t))) = join (M (interp M) (interp M (Map² f t)))
M² f (M (interp M) (interp M t)) = M (interp M) (interp M (Map² f t))
M² f (M (interp M) (interp M t)) = M (interp M) (interp M (Map (Map f) t))
M² f (M (interp M) (interp M t)) = M (interp M) (M (Map f) (interp M t))
M² f (M (interp M) (interp M t)) = M (interp M . Map f) (interp M t)
M² f (M (interp M) (interp M t)) = M (M f . interp M) (interp M t)
M² f (M (interp M) (interp M t)) = M (M f) (M (interp M) (interp M t))
M² f (M (interp M) (interp M t)) = M² f (M (interp M) (interp M t)) ✔

(t : FreeMonad a) ⊦ interp (Join (Pure t)) = interp M t : M a
                    join (M (interp M) (interp M (Pure t))) = interp M t
                    join (M (interp M) (pure t)) = interp M t
                    join (pure (interp M t)) = interp M t
                    interp M t = interp M t ✔

(t : FreeMonad a) ⊦ interp M (Join (Map Pure t)) = interp M t : M a
                    join (M (interp M) (interp M (Map Pure t))) = interp M t
                    join (M (interp M) (M Pure (interp M t))) = interp M t
                    join (M (interp M . Pure) (interp M t)) = interp M t
                    join (M pure (interp M t)) = interp M t
                    interp M t = interp M t ✔

(t : FreeMonad³ a) ⊦ interp (Join (Map Join t)) = interp (Join (Join t)) : M a
                     join (M (interp M) (interp M (Map Join t))) = join (M (interp M) (interp M (Join t)))
                     join (M (interp M) (M Join (interp M t))) = join (M (interp M) (interp M (Join t)))
                     join (M (interp M . Join) (interp M t)) = join (M (interp M) (interp M (Join t)))
                     join (M (join . M (interp M) . interp M) (interp M t)) = join (M (interp M) (interp M (Join t)))
                     join (M join (M (M (interp M) . interp M) (interp M t))) = join (M (interp M) (interp M (Join t)))
                     join (join (M (M (interp M) . interp M) (interp M t))) = join (M (interp M) (interp M (Join t)))
                     join (join (M (M (interp M) . interp M) (interp M t))) = join (M (interp M) (join (M (interp M) (interp M t))))
                     join (join (M (M (interp M) . interp M) (interp M t))) = join (join (M² (interp M) (M (interp M) (interp M t))))
                     M (M (interp M) . interp M) (interp M t) = M² (interp M) (M (interp M) (interp M t))
                     M (M (interp M) . interp M) (interp M t) = M (M (interp M)) (M (interp M) (interp M t))
                     M (M (interp M)) (M (interp M) (interp M t)) = M (M (interp M)) (M (interp M) (interp M t)) ✔


//Note that interp is automatically a natural transformation (preserves map) and
//a monad morphism (moreover preserves pure and join).

//Let's show that interp is a unique monad morphism
(M : Monad) (μ : FreeMonad ⇝ M) ⊦ μ = interp M : ∀a. FreeMonad a → M a
//By function extensionality
(M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad a) ⊦ μ t = interp M t : M a
//By induction on t
* (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (x : a) ⊦ μ (Pure x) = interp M (Pure x)
  //by definition of interp
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (x : a) ⊦ μ (Pure x) = pure x
  //by properties of a monad morphism
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (x : a) ⊦ pure x = pure x ✔

* (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad a) (f : a → b) ⊦ μ (Map f t) = interp M (Map f t) : M b
  //By definition of interp
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad a) (f : a → b) ⊦ μ (Map f t) = Map f (interp M t)
  //By properties of a monad morphism
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad a) (f : a → b) ⊦ M f (μ t) = M f (interp M t)
  //congruence
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad a) (f : a → b) ⊦ μ t = interp M t
  //By induction hypothesis
  ✔

* (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad² a) ⊦ μ (Join t) = interp M (Join t) : M b
  //By definition of interp
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad² a) ⊦ μ (Join t) = join (M (interp M) (interp M t))
  //By properties of a monad morphism
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad² a) ⊦ join (M μ (μ t)) = join (M (interp M) (interp M t))
  //congruence
  (M : Monad) (μ : FreeMonad ⇝ M) (a : 𝕌) (t : FreeMonad² a) ⊦ M μ (μ t) = M (interp M) (interp M t)
  //By induction hypothesis
  ✔

//Hence FreeMonad is the initial object in the category of monads.

//Let's show that FreeMonad and Id are isomorphic objects of the category of monads.

//There is a monad morphism:
pure : ∀a. Id a → FreeMonad a

//interp gives us a morphism in other direction:
interp Id : ∀a. FreeMonad a → Id a

interp Id . pure = pure = id //follows immediately from definition of interp

pure . interp Id = id
//By function extensionality
(t : FreeMonad a) ⊦ pure (interp Id t) = t
//By induction on t
* (x : a) ⊦ pure (interp Id (Pure x)) = Pure x
            pure (pure x) = Pure x
            pure (id x) = Pure x
            pure x = Pure x
            Pure x = Pure x ✔
* (t : FreeMonad a) (f : a → b) ⊦ pure (interp Id (Map f t)) = Map f t
                                  pure (Id f (interp Id t)) = Map f t
                                  //pure is a natural transformation
                                  Map f (pure (interp Id t)) = Map f t
                                  //By induction hypothesis
                                  Map f t = Map f t ✔
* (t : FreeMonad² a) ⊦ Pure (interp Id (Join t)) = Join t
                       Pure (join (Id (interp Id) (interp Id t))) = Join t
                       //pure preserves join
                       Join (pure (Id pure (Id (interp Id) (interp Id t)))) = Join t
                       Join (pure (Id pure (interp Id (interp Id t)))) = Join t
                       Join (interp Id (interp Id t)) = Join t
                       Join (interp Id t) = Join t
                       Join t = Join t ✔

//Hence Id and FreeMonad are isomorphic objects of the monad category.

∀M. ((∀a. a → M a) ≅ 𝟙)
≅
∀M. ((∀a. Id a → M a) ≅ 𝟙)
≅
∀M. ((∀a. FreeMonad a → M a) ≅ 𝟙)
//I am stuck
//We know that the set of monad morphisms (Free ⇝ M) is isomorphic to singleton set but we can't say the same about
//merely functions (∀a. FreeMonad a → M a)
